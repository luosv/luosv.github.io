<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[如何优雅的设计java异常]]></title>
      <url>%2F2017%2F03%2F31%2FJava%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8%2F</url>
      <content type="text"><![CDATA[本文转载自Lrwin的java技术博客 导语 异常处理是程序开发中必不可少操作之一，但如何正确优雅的对异常进行处理确是一门学问，笔者根据自己的开发经验来谈一谈我是如何对异常进行处理的。由于本文只作一些经验之谈，不涉及到基础知识部分，如果读者对异常的概念还很模糊，请先查看基础知识。 如何选择异常类型异常的类别正如我们所知道的，java中的异常的超类是java.lang.Throwable(后文省略为Throwable),它有两个比较重要的子类,java.lang.Exception(后文省略为Exception)和java.lang.Error(后文省略为Error)，其中Error由JVM虚拟机进行管理,如我们所熟知的OutOfMemoryError异常等，所以我们本文不关注Error异常，那么我们细说一下Exception异常。Exception异常有个比较重要的子类，叫做RuntimeException。我们将RuntimeException或其他继承自RuntimeException的子类称为非受检异常(unchecked Exception)，其他继承自Exception异常的子类称为受检异常(checked Exception)。本文重点来关注一下受检异常和非受检异常这两种异常。 如何选择异常从笔者的开发经验来看，如果在一个应用中，需要开发一个方法(如某个功能的service方法)，这个方法如果中间可能出现异常，那么你需要考虑这个异常出现之后是否调用者可以处理，并且你是否希望调用者进行处理，如果调用者可以处理，并且你也希望调用者进行处理，那么就要抛出受检异常，提醒调用者在使用你的方法时，考虑到如果抛出异常时如果进行处理，相似的，如果在写某个方法时，你认为这是个偶然异常，理论上说，你觉得运行时可能会碰到什么问题，而这些问题也许不是必然发生的，也不需要调用者显示的通过异常来判断业务流程操作的，那么这时就可以使用一个RuntimeException这样的非受检异常.好了，估计我上边说的这段话，你读了很多遍也依然觉得晦涩了。那么，请跟着我的思路，在慢慢领会一下。 什么时候才需要抛异常首先我们需要了解一个问题，什么时候才需要抛异常？异常的设计是方便给开发者使用的，但不是乱用的，笔者对于什么时候抛异常这个问题也问了很多朋友，能给出准确答案的确实不多。其实这个问题很简单，如果你觉得某些”问题”解决不了了，那么你就可以抛出异常了。比如，你在写一个service,其中在写到某段代码处,你发现可能会产生问题，那么就请抛出异常吧，相信我，你此时抛出异常将是一个最佳时机。 应该抛出怎样的异常了解完了什么时候才需要抛出异常后，我们再思考一个问题，真的当我们抛出异常时，我们应该选用怎样的异常呢？究竟是受检异常还是非受检异常呢(RuntimeException)呢？我来举例说明一下这个问题，先从受检异常说起,比如说有这样一个业务逻辑，需要从某文件中读取某个数据，这个读取操作可能是由于文件被删除等其他问题导致无法获取从而出现读取错误，那么就要从redis或mysql数据库中再去获取此数据,参考如下代码，getKey(Integer)为入口程序. 12345678910111213141516171819202122public String getKey(Integer key)&#123; String value; try &#123; InputStream inputStream = getFiles("/file/nofile"); //接下来从流中读取key的value指 value = ...; &#125; catch (Exception e) &#123; //如果抛出异常将从mysql或者redis进行取之 value = ...; &#125;&#125;public InputStream getFiles(String path) throws Exception &#123; File file = new File(path); InputStream inputStream = null; try &#123; inputStream = new BufferedInputStream(new FileInputStream(file)); &#125; catch (FileNotFoundException e) &#123; throw new Exception("I/O读取错误",e.getCause()); &#125; return inputStream;&#125; ok，看了以上代码以后，你也许心中有一些想法，原来受检异常可以控制义务逻辑，对，没错，通过受检异常真的可以控制业务逻辑，但是切记不要这样使用，我们应该合理的抛出异常，因为程序本身才是流程，异常的作用仅仅是当你进行不下去的时候找到的一个借口而已，它并不能当成控制程序流程的入口或出口，如果这样使用的话，是在将异常的作用扩大化，这样将会导致代码复杂程度的增加，耦合性会提高，代码可读性降低等问题。那么就一定不要使用这样的异常吗？其实也不是，在真的有这样的需求的时候，我们可以这样使用，只是切记，不要把它真的当成控制流程的工具或手段。那么究竟什么时候才要抛出这样的异常呢？要考虑，如果调用者调用出错后，一定要让调用者对此错误进行处理才可以，满足这样的要求时，我们才会考虑使用受检异常。接下来，我们来看一下非受检异常呢(RuntimeException)，对于RuntimeException这种异常，我们其实很多见，比如java.lang.NullPointerException／java.lang.IllegalArgumentException等，那么这种异常我们时候抛出呢？当我们在写某个方法的时候，可能会偶然遇到某个错误，我们认为这个问题时运行时可能为发生的，并且理论上讲，没有这个问题的话，程序将会正常执行的时候，它不强制要求调用者一定要捕获这个异常，此时抛出RuntimeException异常,举个例子，当传来一个路径的时候，需要返回一个路径对应的File对象: 123456789101112public void test() &#123; myTest.getFiles("");&#125;public File getFiles(String path) &#123; if(null == path || "".equals(path))&#123; throw new NullPointerException("路径不能为空!"); &#125; File file = new File(path); return file;&#125; 上述例子表明，如果调用者调用getFiles(String)的时候如果path是空，那么就抛出空指针异常(它是RuntimeException的子类),调用者不用显示的进行try…catch…操作进行强制处理.这就要求调用者在调用这样的方法时先进行验证，避免发生RuntimeException.如下: 123456789101112131415public void test() &#123; String path = "/a/b.png"; if(null != path &amp;&amp; !"".equals(path))&#123; myTest.getFiles(""); &#125;&#125;public File getFiles(String path) &#123; if(null == path || "".equals(path))&#123; throw new NullPointerException("路径不能为空!"); &#125; File file = new File(path); return file;&#125; 应该选用哪种异常通过以上的描述和举例，可以总结出一个结论，RuntimeException异常和受检异常之间的区别就是:是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。 场景介绍和技术选型架构描述正如我们所知，传统的项目都是以MVC框架为基础进行开发的，本文主要从使用restful风格接口的设计来体验一下异常处理的优雅。我们把关注点放在restful的api层(和web中的controller层类似)和service层，研究一下在service中如何抛出异常，然后api层如何进行捕获并且转化异常。使用的技术是:spring-boot,jpa(hibernate),mysql,如果对这些技术不是太熟悉，读者需要自行阅读相关材料。 业务场景描述选择一个比较简单的业务场景，以电商中的收货地址管理为例，用户在移动端进行购买商品时，需要进行收货地址管理，在项目中，提供一些给移动端进行访问的api接口，如:添加收货地址，删除收货地址，更改收货地址，默认收货地址设置，收货地址列表查询，单个收货地址查询等接口。 构建约束条件ok，这个是设置好的一个很基本的业务场景，当然，无论什么样的api操作，其中都包含一些规则: 添加收货地址:入参: 用户id 收货地址实体信息 约束: 用户id不能为空，且此用户确实是存在 的 收货地址的必要字段不能为 空 如果用户还没有收货地址，当此收货地址创建时设置成默认收货地址 — 删除收货地址:入参: 用户id 收货地址id 约束: 用户id不能为空，且此用户确实是存在的 收货地址不能为空，且此收货地址确实是存在的 判断此收货地址是否是用户的收货地址 判断此收货地址是否为默认收货地址，如果是默认收货地址，那么不能进行删除 更改收货地址:入参: 用户id 收货地址id 约束: 用户id不能为空，且此用户确实是存在的 收货地址不能为空，且此收货地址确实是存在的 判断此收货地址是否是用户的收货地址 默认地址设置:入参: 用户id 收货地址id 约束: 用户id不能为空，且此用户确实是存在的 收货地址不能为空，且此收货地址确实是存在的 判断此收货地址是否是用户的收货地址 收货地址列表查询:入参: 用户id 约束: 用户id不能为空，且此用户确实是存在的 单个收货地址查询:入参: 用户id 收货地址id 约束: 用户id不能为空，且此用户确实是存在的 收货地址不能为空，且此收货地址确实是存在的 判断此收货地址是否是用户的收货地址 约束判断和技术选型对于上述列出的约束条件和功能列表，我选择几个比较典型的异常处理场景进行分析:添加收货地址，删除收货地址，获取收货地址列表。那么应该有哪些必要的知识储备呢，让我们看一下收货地址这个功能:添加收货地址中需要对用户id和收货地址实体信息就行校验，那么对于非空的判断，我们如何进行工具的选择呢？传统的判断如下: 123456789101112/** * 添加地址 * @param uid * @param address * @return */public Address addAddress(Integer uid,Address address)&#123; if(null != uid)&#123; //进行处理.. &#125; return null;&#125; 上边的例子，如果只判断uid为空还好，如果再去判断address这个实体中的某些必要属性是否为空，在字段很多的情况下，这无非是灾难性的。那我们应该怎么进行这些入参的判断呢，给大家介绍两个知识点: Guava中的Preconditions类实现了很多入参方法的判断 jsr 303的validation规范(目前实现比较全的是hibernate实现的hibernate-validator)如果使用了这两种推荐技术，那么入参的判断会变得简单很多。推荐大家多使用这些成熟的技术和jar工具包，他可以减少很多不必要的工作量。我们只需要把重心放到业务逻辑上。而不会因为这些入参的判断耽误更多的时间。 如何优雅的设计java异常domain介绍根据项目场景来看，需要两个domain模型，一个是用户实体，一个是地址实体.Address domain如下: 123456789101112131415@Entity@Datapublic class Address &#123; @Id @GeneratedValue private Integer id; private String province;//省 private String city;//市 private String county;//区 private Boolean isDefault;//是否是默认地址 @ManyToOne(cascade=&#123;CascadeType.ALL&#125;) @JoinColumn(name="uid") private User user;&#125; User domain如下: 1234567891011@Entity@Datapublic class User &#123; @Id @GeneratedValue private Integer id; private String name;//姓名 @OneToMany(cascade= CascadeType.ALL,mappedBy="user",fetch = FetchType.LAZY) private Set&lt;Address&gt; addresses;&#125; ok,上边是一个模型关系，用户-收货地址的关系是1-n的关系。上边的@Data是使用了一个叫做lombok的工具，它自动生成了Setter和Getter等方法，用起来非常方便，感兴趣的读者可以自行了解一下。 dao介绍数据连接层，我们使用了spring-data-jpa这个框架，它要求我们只需要继承框架提供的接口，并且按照约定对方法进行取名，就可以完成我们想要的数据库操作。用户数据库操作如下: 1234@Repositorypublic interface IUserDao extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 收货地址操作如下: 1234@Repositorypublic interface IAddressDao extends JpaRepository&lt;Address,Integer&gt; &#123;&#125; 正如读者所看到的，我们的DAO只需要继承JpaRepository,它就已经帮我们完成了基本的CURD等操作，如果想了解更多关于spring-data的这个项目，请参考一下spring的官方文档，它比不方案我们对异常的研究。 Service异常设计ok，终于到了我们的重点了，我们要完成service一些的部分操作:添加收货地址，删除收货地址，获取收货地址列表.首先看我的service接口定义: 123456789101112131415161718192021222324public interface IAddressService &#123;/** * 创建收货地址 * @param uid * @param address * @return */Address createAddress(Integer uid,Address address);/** * 删除收货地址 * @param uid * @param aid */void deleteAddress(Integer uid,Integer aid);/** * 查询用户的所有收货地址 * @param uid * @return */List&lt;Address&gt; listAddresses(Integer uid);&#125; 我们来关注一下实现: 添加收货地址首先再来看一下之前整理的约束条件: 入参: 用户id 收货地址实体信息 约束: 用户id不能为空，且此用户确实是存在的 收货地址的必要字段不能为空 如果用户还没有收货地址，当此收货地址创建时设置成默认收货地址 先看以下代码实现: 123456789101112131415161718192021 @Overridepublic Address createAddress(Integer uid, Address address) &#123; //============ 以下为约束条件 ============== //1.用户id不能为空，且此用户确实是存在的 Preconditions.checkNotNull(uid); User user = userDao.findOne(uid); if(null == user)&#123; throw new RuntimeException("找不到当前用户!"); &#125; //2.收货地址的必要字段不能为空 BeanValidators.validateWithException(validator, address); //3.如果用户还没有收货地址，当此收货地址创建时设置成默认收货地址 if(ObjectUtils.isEmpty(user.getAddresses()))&#123; address.setIsDefault(true); &#125; //============ 以下为正常执行的业务逻辑 ============== address.setUser(user); Address result = addressDao.save(address); return result;&#125; 其中，已经完成了上述所描述的三点约束条件，当三点约束条件都满足时，才可以进行正常的业务逻辑，否则将抛出异常(一般在此处建议抛出运行时异常-RuntimeException)。 介绍以下以上我所用到的技术: Preconfitions.checkNotNull(T t)这个是使用Guava中的com.google.common.base.Preconditions进行判断的，因为service中用到的验证较多，所以建议将Preconfitions改成静态导入的方式: 1import static com.google.common.base.Preconditions.checkNotNull; 当然Guava的github中的说明也建议我们这样使用。 BeanValidators.validateWithException(validator, address);这个使用了hibernate实现的jsr 303规范来做的，需要传入一个validator和一个需要验证的实体,那么validator是如何获取的呢,如下: @Configurationpublic class BeanConfigs { 1234@Beanpublic javax.validation.Validator getValidator()&#123; return new LocalValidatorFactoryBean();&#125; } 他将获取一个Validator对象，然后我们在service中进行注入便可以使用了: 12 @Autowired private Validator validator ; 那么BeanValidators这个类是如何实现的？其实实现方式很简单，只要去判断jsr 303的标注注解就ok了。那么jsr 303的注解写在哪里了呢？当然是写在address实体类中了: 12345678910111213141516171819@Entity@Setter@Getterpublic class Address &#123;@Id @GeneratedValue private Integer id; @NotNullprivate String province;//省@NotNullprivate String city;//市@NotNullprivate String county;//区private Boolean isDefault = false;//是否是默认地址@ManyToOne(cascade=&#123;CascadeType.ALL&#125;)@JoinColumn(name="uid")private User user;&#125; 写好你需要的约束条件来进行判断，如果合理的话，才可以进行业务操作，从而对数据库进行操作。这块的验证是必须的，一个最主要的原因是:这样的验证可以避免脏数据的插入。如果读者有正式上线的经验的话，就可以理解这样的一个事情，任何的代码错误都可以容忍和修改，但是如果出现了脏数据问题，那么它有可能是一个毁灭性的灾难。程序的问题可以修改，但是脏数据的出现有可能无法恢复。所以这就是为什么在service中一定要判断好约束条件，再进行业务逻辑操作的原因了。 此处的判断为业务逻辑判断，是从业务角度来进行筛选判断的，除此之外，有可能在很多场景中都会有不同的业务条件约束，只需要按照要求来做就好。 对于约束条件的总结如下: 基本判断约束(null值等基本判断) 实体属性约束(满足jsr 303等基础判断) 业务条件约束(需求提出的不同的业务约束) 当这个三点都满足时，才可以进行下一步操作 ok,基本介绍了如何做一个基础的判断，那么再回到异常的设计问题上，上述代码已经很清楚的描述如何在适当的位置合理的判断一个异常了，那么如何合理的抛出异常呢？只抛出RuntimeException就算是优雅的抛出异常吗？当然不是，对于service中的抛出异常，笔者认为大致有两种抛出的方法: 抛出带状态码RumtimeException异常 抛出指定类型的RuntimeException异常 相对这两种异常的方式进行结束，第一种异常指的是我所有的异常都抛RuntimeException异常，但是需要带一个状态码，调用者可以根据状态码再去查询究竟service抛出了一个什么样的异常。第二种异常是指在service中抛出什么样的异常就自定义一个指定的异常错误，然后在进行抛出异常。一般来讲，如果系统没有别的特殊需求的时候，在开发设计中，建议使用第二种方式。但是比如说像基础判断的异常，就可以完全使用guava给我们提供的类库进行操作。jsr 303异常也可以使用自己封装好的异常判断类进行操作，因为这两种异常都是属于基础判断，不需要为它们指定特殊的异常。但是对于第三点义务条件约束判断抛出的异常，就需要抛出指定类型的异常了。对于 1throw new RuntimeException("找不到当前用户!"); 定义一个特定的异常类来进行这个义务异常的判断: 123456789public class NotFindUserException extends RuntimeException &#123;public NotFindUserException() &#123; super("找不到此用户");&#125;public NotFindUserException(String message) &#123; super(message);&#125;&#125; 然后将此处改为: 1throw new NotFindUserException("找不到当前用户!"); or 1throw new NotFindUserException(); ok,通过以上对service层的修改，代码更改如下: 123456789101112131415161718192021@Overridepublic Address createAddress(Integer uid, Address address) &#123; //============ 以下为约束条件 ============== //1.用户id不能为空，且此用户确实是存在的 checkNotNull(uid); User user = userDao.findOne(uid); if(null == user)&#123; throw new NotFindUserException("找不到当前用户!"); &#125; //2.收货地址的必要字段不能为空 BeanValidators.validateWithException(validator, address); //3.如果用户还没有收货地址，当此收货地址创建时设置成默认收货地址 if(ObjectUtils.isEmpty(user.getAddresses()))&#123; address.setIsDefault(true); &#125; //============ 以下为正常执行的业务逻辑 ============== address.setUser(user); Address result = addressDao.save(address); return result;&#125; 这样的service就看起来稳定性和理解性就比较强了。 删除收货地址:入参: 用户id 收货地址id 约束: 用户id不能为空，且此用户确实是存在的 收货地址不能为空，且此收货地址确实是存在的 判断此收货地址是否是用户的收货地址 判断此收货地址是否为默认收货地址，如果是默认收货地址，那么不能进行删除 它与上述添加收货地址类似，故不再赘述，delete的service设计如下: 123456789101112131415161718192021222324252627@Overridepublic void deleteAddress(Integer uid, Integer aid) &#123; //============ 以下为约束条件 ============== //1.用户id不能为空，且此用户确实是存在的 checkNotNull(uid); User user = userDao.findOne(uid); if(null == user)&#123; throw new NotFindUserException(); &#125; //2.收货地址不能为空，且此收货地址确实是存在的 checkNotNull(aid); Address address = addressDao.findOne(aid); if(null == address)&#123; throw new NotFindAddressException(); &#125; //3.判断此收货地址是否是用户的收货地址 if(!address.getUser().equals(user))&#123; throw new NotMatchUserAddressException(); &#125; //4.判断此收货地址是否为默认收货地址，如果是默认收货地址，那么不能进行删除 if(address.getIsDefault())&#123; throw new DefaultAddressNotDeleteException(); &#125; //============ 以下为正常执行的业务逻辑 ============== addressDao.delete(address);&#125; 设计了相关的四个异常类:NotFindUserException,NotFindAddressException,NotMatchUserAddressException,DefaultAddressNotDeleteException.根据不同的业务需求抛出不同的异常。 获取收货地址列表:入参: 用户id 约束: 用户id不能为空，且此用户确实是存在的 代码如下: 1234567891011121314 @Overridepublic List&lt;Address&gt; listAddresses(Integer uid) &#123; //============ 以下为约束条件 ============== //1.用户id不能为空，且此用户确实是存在的 checkNotNull(uid); User user = userDao.findOne(uid); if(null == user)&#123; throw new NotFindUserException(); &#125; //============ 以下为正常执行的业务逻辑 ============== User result = userDao.findOne(uid); return result.getAddresses();&#125; api异常设计大致有两种抛出的方法: 抛出带状态码RumtimeException异常 抛出指定类型的RuntimeException异常 这个是在设计service层异常时提到的，通过对service层的介绍，我们在service层抛出异常时选择了第二种抛出的方式，不同的是，在api层抛出异常我们需要使用这两种方式进行抛出:要指定api异常的类型，并且要指定相关的状态码，然后才将异常抛出，这种异常设计的核心是让调用api的使用者更能清楚的了解发生异常的详细信息，除了抛出异常外，我们还需要将状态码对应的异常详细信息以及异常有可能发生的问题制作成一个对应的表展示给用户，方便用户的查询。（如github提供的api文档，微信提供的api文档等）,还有一个好处:如果用户需要自定义提示消息，可以根据返回的状态码进行提示的修改。 api验证约束首先对于api的设计来说，需要存在一个dto对象，这个对象负责和调用者进行数据的沟通和传递，然后dto-&gt;domain在传给service进行操作，这一点一定要注意，第二点，除了说道的service需要进行基础判断(null判断)和jsr 303验证以外，同样的，api层也需要进行相关的验证，如果验证不通过的话，直接返回给调用者，告知调用失败，不应该带着不合法的数据再进行对service的访问，那么读者可能会有些迷惑，不是service已经进行验证了，为什么api层还需要进行验证么？这里便设计到了一个概念:编程中的墨菲定律，如果api层的数据验证疏忽了，那么有可能不合法数据就带到了service层，进而讲脏数据保存到了数据库。 所以缜密编程的核心是:永远不要相信收到的数据是合法的。 api异常设计设计api层异常时，正如我们上边所说的，需要提供错误码和错误信息，那么可以这样设计，提供一个通用的api超类异常，其他不同的api异常都继承自这个超类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ApiException extends RuntimeException &#123;protected Long errorCode ;protected Object data ;public ApiException(Long errorCode,String message,Object data,Throwable e)&#123; super(message,e); this.errorCode = errorCode ; this.data = data ;&#125;public ApiException(Long errorCode,String message,Object data)&#123; this(errorCode,message,data,null);&#125;public ApiException(Long errorCode,String message)&#123; this(errorCode,message,null,null);&#125;public ApiException(String message,Throwable e)&#123; this(null,message,null,e);&#125;public ApiException()&#123;&#125;public ApiException(Throwable e)&#123; super(e);&#125;public Long getErrorCode() &#123; return errorCode;&#125;public void setErrorCode(Long errorCode) &#123; this.errorCode = errorCode;&#125;public Object getData() &#123; return data;&#125;public void setData(Object data) &#123; this.data = data;&#125; } 然后分别定义api层异常:ApiDefaultAddressNotDeleteException,ApiNotFindAddressException,ApiNotFindUserException,ApiNotMatchUserAddressException.以默认地址不能删除为例: 12345public class ApiDefaultAddressNotDeleteException extends ApiException &#123;public ApiDefaultAddressNotDeleteException(String message) &#123; super(AddressErrorCode.DefaultAddressNotDeleteErrorCode, message, null);&#125; } AddressErrorCode.DefaultAddressNotDeleteErrorCode就是需要提供给调用者的错误码。错误码类如下: 123456public abstract class AddressErrorCode &#123; public static final Long DefaultAddressNotDeleteErrorCode = 10001L;//默认地址不能删除 public static final Long NotFindAddressErrorCode = 10002L;//找不到此收货地址 public static final Long NotFindUserErrorCode = 10003L;//找不到此用户 public static final Long NotMatchUserAddressErrorCode = 10004L;//用户与收货地址不匹配&#125; ok,那么api层的异常就已经设计完了，在此多说一句，AddressErrorCode错误码类存放了可能出现的错误码，更合理的做法是把他放到配置文件中进行管理。 api处理异常api层会调用service层，然后来处理service中出现的所有异常，首先，需要保证一点，一定要让api层非常轻，基本上做成一个转发的功能就好(接口参数，传递给service参数，返回给调用者数据,这三个基本功能)，然后就要在传递给service参数的那个方法调用上进行异常处理。 此处仅以添加地址为例: 123456789101112131415161718192021222324252627 @Autowiredprivate IAddressService addressService;/** * 添加收货地址 * @param addressDTO * @return */@RequestMapping(method = RequestMethod.POST)public AddressDTO add(@Valid @RequestBody AddressDTO addressDTO)&#123; Address address = new Address(); BeanUtils.copyProperties(addressDTO,address); Address result; try &#123; result = addressService.createAddress(addressDTO.getUid(), address); &#125;catch (NotFindUserException e)&#123; throw new ApiNotFindUserException("找不到该用户"); &#125;catch (Exception e)&#123;//未知错误 throw new ApiException(e); &#125; AddressDTO resultDTO = new AddressDTO(); BeanUtils.copyProperties(result,resultDTO); resultDTO.setUid(result.getUser().getId()); return resultDTO;&#125; 这里的处理方案是调用service时，判断异常的类型，然后将任何service异常都转化成api异常，然后抛出api异常，这是常用的一种异常转化方式。相似删除收货地址和获取收货地址也类似这样处理，在此，不在赘述。 api异常转化已经讲解了如何抛出异常和何如将service异常转化为api异常，那么转化成api异常直接抛出是否就完成了异常处理呢？ 答案是否定的，当抛出api异常后，我们需要把api异常返回的数据(json or xml)让用户看懂，那么需要把api异常转化成dto对象(ErrorDTO),看如下代码: 1@ControllerAdvice(annotations = RestController.class) class ApiExceptionHandlerAdvice { 123456789101112131415161718192021222324/** * Handle exceptions thrown by handlers. */@ExceptionHandler(value = Exception.class)@ResponseBodypublic ResponseEntity&lt;ErrorDTO&gt; exception(Exception exception,HttpServletResponse response) &#123; ErrorDTO errorDTO = new ErrorDTO(); if(exception instanceof ApiException)&#123;//api异常 ApiException apiException = (ApiException)exception; errorDTO.setErrorCode(apiException.getErrorCode()); &#125;else&#123;//未知异常 errorDTO.setErrorCode(0L); &#125; errorDTO.setTip(exception.getMessage()); ResponseEntity&lt;ErrorDTO&gt; responseEntity = new ResponseEntity&lt;&gt;(errorDTO,HttpStatus.valueOf(response.getStatus())); return responseEntity;&#125;@Setter@Getterclass ErrorDTO&#123; private Long errorCode; private String tip;&#125; } ok,这样就完成了api异常转化成用户可以读懂的DTO对象了，代码中用到了@ControllerAdvice，这是spring MVC提供的一个特殊的切面处理。 当调用api接口发生异常时，用户也可以收到正常的数据格式了,比如当没有用户(uid为2)时，却为这个用户添加收货地址,postman(Google plugin 用于模拟http请求)之后的数据: 1234&#123; "errorCode": 10003, "tip": "找不到该用户"&#125; 总结本文只从如何设计异常作为重点来讲解，涉及到的api传输和service的处理，还有待优化，比如api接口访问需要使用https进行加密，api接口需要OAuth2.0授权或api接口需要签名认证等问题，文中都未曾提到，本文的重心在于异常如何处理，所以读者只需关注涉及到异常相关的问题和处理方式就可以了。希望本篇文章对你理解异常有所帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[细思极恐-你真的会写java吗?]]></title>
      <url>%2F2017%2F03%2F31%2FJava%2F%E7%BB%86%E6%80%9D%E6%9E%81%E6%81%90-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99java%E5%90%97%2F</url>
      <content type="text"><![CDATA[本文转载自Lrwin的java技术博客 导语 自2013年毕业后，今年已经是我工作的第4个年头了，总在做java相关的工作，终于有时间坐下来，写一篇关于java写法的一篇文章，来探讨一下如果你真的是一个java程序员，那你真的会写java吗?笔者是一个务实的程序员，故本文绝非扯淡文章，文中内容都是干货，望读者看后，能有所收获。 文章核心其实，本不想把标题写的那么恐怖，只是发现很多人干了几年java以后，都自认为是一个不错的java程序员了，可以拿着上万的工资都处宣扬自己了，写这篇文章的目的并不是嘲讽和我一样做java的同行们，只是希望读者看到此骗文章后，可以和我一样，心平气和的争取做一个优秀的程序员。 讲述方向由于一直从事移动互联网相关工作，java开发中经常和移动端打交道或者做一些后端的工作，所以本篇文章更可能涉及和移动端的交互或者与后端的交互方式，笔者希望以自身的一些学习经验或者开发经验，可以带动认真阅读本篇文章的读者们，让大家对java有一个更好的态度去学习它，它不只是一个赚钱的工具而已。 笔者身边有很多与笔者年龄相仿或年龄更大的朋友或同事，经常有人问我：“你现在还在学习吗？我觉得没什么好学的，这些东西都差不多”，我总是回答只要有时间，我就要看一会书，这个时候，大家都会露出一副不屑的眼神或笑容。其实，非常能理解身边朋友或同事的看法，以目前状态来讲，大多都是工作至少5年的程序员了，对于公司大大小小的业务需要，以目前的知识储备来讲，都可以轻松应对，“没有什么好学的”其实这句话没有多大的问题，但是，如果你对编程还有一点点兴趣，只是不知道如何努力或改进，希望本篇文章可以帮到你。 技术点本文不是一个吹嘘的文章，不会讲很多高深的架构，相反，会讲解很多基础的问题和写法问题，如果读者自认为基础问题和写法问题都是不是问题，那请忽略这篇文章，节省出时间去做一些有意义的事情。 开发工具不知道有多少”老”程序员还在使用eclipse，这些程序员们要不就是因循守旧，要不就是根本就不知道其他好的开发工具的存在，eclipse吃内存卡顿的现象以及各种偶然莫名异常的出现，都告知我们是时候寻找新的开发工具了。 更换IDE根本就不想多解释要换什么样的IDE，如果你想成为一个优秀的java程序员，请更换intellij idea. 使用idea的好处，请搜索谷歌。 别告诉我快捷键不好用更换IDE不在我本文的重点内容中，所以不下想用太多的篇幅去写为什么更换IDE，请谷歌。 在这里，我只能告诉你，更换IDE只为了更好、更快的写好java代码。原因略。 别告诉我快捷键不好用，请尝试新事物。 beanbean使我们使用最多的模型之一，我将以大篇幅去讲解bean，希望读者好好体会。 domain包名根据很多java程序员的”经验”来看，一个数据库表则对应着一个domain对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是domain。但是你错了，domain是一个领域对象，往往我们再做传统java软件web开发中，这些domain都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的，所以，以这个理论来讲，这些domain都应该是一个普通的entity对象，并非领域对象，所以请把包名改为:com.xxx.entity。 如果你还不理解我说的话，请看一下Vaughn Vernon出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》(实现领域驱动设计)这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。 DTO数据传输我们应该使用DTO对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端api设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候(input or output)，这些对象成为DTO对象。请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是DTO对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到OMS 或者 ERP系统，这些对接的返回值以及入参也叫DTO对象。 我们约定某对象如果是DTO对象，就将名称改为XXDTO,比如订单下发OMS：OMSOrderInputDTO。 DTO转化正如我们所知，DTO为系统与外界交互的模型对象，那么肯定会有一个步骤是将DTO对象转化为BO对象或者是普通的entity对象，让service层去处理。 场景比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。 12345678910111213141516@RequestMapping("/v1/api/user")@RestControllerpublic class UserApi &#123; @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO)&#123; User user = new User(); user.setUsername(userInputDTO.getUsername()); user.setAge(userInputDTO.getAge()); return userService.addUser(user); &#125;&#125; 我们只关注一下上述代码中的转化代码，其他内容请忽略: 123User user = new User();user.setUsername(userInputDTO.getUsername());user.setAge(userInputDTO.getAge()); 请使用工具上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有20个字段，我们要如何做呢？ 一个一个进行set数据吗？当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。 网上有很多工具，支持浅拷贝或深拷贝的Utils. 举个例子，我们可以使用org.springframework.beans.BeanUtils#copyProperties对代码进行重构和优化: 1234567@PostMappingpublic User addUser(UserInputDTO userInputDTO)&#123; User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return userService.addUser(user);&#125; BeanUtils.copyProperties是一个浅拷贝方法，复制属性时，我们只需要把DTO对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。如果你在做DTO转化的时候一直使用set进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰! 转化的语义上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写java代码时，更多的需要考虑语义的操作，再看上边的代码: 12User user = new User();BeanUtils.copyProperties(userInputDTO,user); 虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好,所以代码改成如下: 12345678910111213@PostMapping public User addUser(UserInputDTO userInputDTO)&#123; User user = convertFor(userInputDTO); return userService.addUser(user); &#125; private User convertFor(UserInputDTO userInputDTO)&#123; User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; &#125; 这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如: 12User user = convertFor(userInputDTO);return userService.addUser(user); 这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。 如上所述，是一种重构方式，读者可以参考Martin Fowler的《Refactoring Imporving the Design of Existing Code》(重构 改善既有代码的设计) 这本书中的Extract Method重构方式。 抽象接口定义当实际工作中，完成了几个api的DTO转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。如果接口被定义以后，那么convertFor这个方法的语义将产生变化，他将是一个实现类。 看一下抽象后的接口: 123public interface DTOConvert&lt;S,T&gt; &#123; T convert(S s);&#125; 虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的java程序员，请为你想做的抽象接口，做好泛型吧。 我们再来看接口实现: 12345678public class UserInputDTOConvert implements DTOConvert &#123; @Override public User convert(UserInputDTO userInputDTO) &#123; User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; &#125;&#125; 我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范: 1234567891011121314@RequestMapping("/v1/api/user")@RestControllerpublic class UserApi &#123; @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO)&#123; User user = new UserInputDTOConvert().convert(userInputDTO); return userService.addUser(user); &#125;&#125; review code如果你是一个优秀的java程序员，我相信你应该和我一样，已经数次重复review过自己的代码很多次了。我们再看这个保存用户的例子，你将发现，api中返回值是有些问题的，问题就在于不应该直接返回User实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的，所以我们更应该返回一个DTO对象，我们可称它为UserOutputDTO: 1234567@PostMappingpublic UserOutputDTO addUser(UserInputDTO userInputDTO)&#123; User user = new UserInputDTOConvert().convert(userInputDTO); User saveUserResult = userService.addUser(user); UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult); return result;&#125; 这样你的api才更健全。 不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的java程序员，请看一下这段我们刚刚抽象完的代码: 1User user = new UserInputDTOConvert().convert(userInputDTO); 你会发现，new这样一个DTO转化对象是没有必要的，而且每一个转化对象都是由在遇到DTO转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和DTO进行聚合呢，看一下我的聚合结果: 1234public class UserInputDTO &#123; private String username; private int age;&#125; 123456789101112131415161718192021222324252627282930313233 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public User convertToUser()&#123; UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert(); User convert = userInputDTOConvert.convert(this); return convert; &#125; private static class UserInputDTOConvert implements DTOConvert&lt;UserInputDTO,User&gt; &#123; @Override public User convert(UserInputDTO userInputDTO) &#123; User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; &#125; &#125;&#125; 然后api中的转化则由: 12User user = new UserInputDTOConvert().convert(userInputDTO);User saveUserResult = userService.addUser(user); 变成了: 12User user = userInputDTO.convertToUser();User saveUserResult = userService.addUser(user); 我们再DTO对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。 再查工具类再来看DTO内部转化的代码，它实现了我们自己定义的DTOConvert接口，但是这样真的就没有问题，不需要再思考了吗？我觉得并不是，对于Convert这种转化语义来讲，很多工具类中都有这样的定义，这中Convert并不是业务级别上的接口定义，它只是用于普通bean之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有Convert转化语义的代码。我仔细阅读了一下GUAVA的源码，发现了com.google.common.base.Convert这样的定义: 12345public abstract class Converter&lt;A, B&gt; implements Function&lt;A, B&gt; &#123; protected abstract B doForward(A a); protected abstract A doBackward(B b); //其他略&#125; 从源码可以了解到，GUAVA中的Convert可以完成正向转化和逆向转化，继续修改我们DTO中转化的这段代码: 12345678private static class UserInputDTOConvert implements DTOConvert&lt;UserInputDTO,User&gt; &#123; @Override public User convert(UserInputDTO userInputDTO) &#123; User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; &#125;&#125; 修改后: 123456789101112131415private static class UserInputDTOConvert extends Converter&lt;UserInputDTO, User&gt; &#123; @Override protected User doForward(UserInputDTO userInputDTO) &#123; User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; &#125; @Override protected UserInputDTO doBackward(User user) &#123; UserInputDTO userInputDTO = new UserInputDTO(); BeanUtils.copyProperties(user,userInputDTO); return userInputDTO; &#125; &#125; 看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的UserInputDTO和UserOutputDTO都转成UserDTO展示给大家: DTO： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class UserDTO &#123; private String username; private int age; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public User convertToUser()&#123; UserDTOConvert userDTOConvert = new UserDTOConvert(); User convert = userDTOConvert.convert(this); return convert; &#125; public UserDTO convertFor(User user)&#123; UserDTOConvert userDTOConvert = new UserDTOConvert(); UserDTO convert = userDTOConvert.reverse().convert(user); return convert; &#125; private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; &#123; @Override protected User doForward(UserDTO userDTO) &#123; User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; &#125; @Override protected UserDTO doBackward(User user) &#123; UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(user,userDTO); return userDTO; &#125; &#125;&#125; api: 1234567@PostMapping public UserDTO addUser(UserDTO userDTO)&#123; User user = userDTO.convertToUser(); User saveResultUser = userService.addUser(user); UserDTO result = userDTO.convertFor(saveResultUser); return result; &#125; 当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的DTO对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的: 12345678910111213private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; &#123; @Override protected User doForward(UserDTO userDTO) &#123; User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; &#125; @Override protected UserDTO doBackward(User user) &#123; throw new AssertionError("不支持逆向转化方法!"); &#125; &#125; 看一下doBackward方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了。 关于异常处理的更详细介绍，可以参考我之前的文章:如何优雅的设计java异常 ，应该可以帮你更好的理解异常。 bean的验证如果你认为我上边写的那个添加用户api写的已经非常完美了，那只能说明你还不是一个优秀的程序员。我们应该保证任何数据的入参到方法体内都是合法的。 为什么要验证很多人会告诉我，如果这些api是提供给前端进行调用的，前端都会进行验证啊，你为什还要验证？其实答案是这样的，我从不相信任何调用我api或者方法的人，比如前端验证失败了，或者某些人通过一些特殊的渠道(比如Charles进行抓包),直接将数据传入到我的api，那我仍然进行正常的业务逻辑处理，那么就有可能产生脏数据！“对于脏数据的产生一定是致命”，这句话希望大家牢记在心，再小的脏数据也有可能让你找几个通宵！ jsr 303验证hibernate提供的jsr 303实现，我觉得目前仍然是很优秀的，具体如何使用，我不想讲，因为谷歌上你可以搜索出很多答案!再以上班的api实例进行说明，我们现在对DTO数据进行检查: 1234567public class UserDTO &#123; @NotNull private String username; @NotNull private int age; //其他代码略&#125; api验证: 1234567@PostMapping public UserDTO addUser(@Valid UserDTO userDTO)&#123; User user = userDTO.convertToUser(); User saveResultUser = userService.addUser(user); UserDTO result = userDTO.convertFor(saveResultUser); return result; &#125; 我们需要将验证结果传给前端，这种异常应该转化为一个api异常(带有错误码的异常)。 1234567891011121314@PostMappingpublic UserDTO addUser(@Valid UserDTO userDTO, BindingResult bindingResult)&#123; checkDTOParams(bindingResult); User user = userDTO.convertToUser(); User saveResultUser = userService.addUser(user); UserDTO result = userDTO.convertFor(saveResultUser); return result;&#125;private void checkDTOParams(BindingResult bindingResult)&#123; if(bindingResult.hasErrors())&#123; //throw new 带验证码的验证错误异常 &#125;&#125; BindingResult是Spring MVC验证DTO后的一个结果集，可以参考spring 官方文档 检查参数后，可以抛出一个“带验证码的验证错误异常”，具体异常设计可以参考如何优雅的设计java异常 拥抱lombok上边的DTO代码，已经让我看的很累了，我相信读者也是一样，看到那么多的Getter和Setter方法，太烦躁了，那时候有什么方法可以简化这些呢。请拥抱lombok,它会帮助我们解决一些让我们很烦躁的问题 去掉Setter和Getter其实这个标题，我不太想说，因为网上太多，但是因为很多人告诉我，他们根本就不知道lombok的存在，所以为了让读者更好的学习，我愿意写这样一个例子： 1234567891011121314151617181920212223242526272829303132333435@Setter@Getterpublic class UserDTO &#123; @NotNull private String username; @NotNull private int age; public User convertToUser()&#123; UserDTOConvert userDTOConvert = new UserDTOConvert(); User convert = userDTOConvert.convert(this); return convert; &#125; public UserDTO convertFor(User user)&#123; UserDTOConvert userDTOConvert = new UserDTOConvert(); UserDTO convert = userDTOConvert.reverse().convert(user); return convert; &#125; private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; &#123; @Override protected User doForward(UserDTO userDTO) &#123; User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; &#125; @Override protected UserDTO doBackward(User user) &#123; throw new AssertionError("不支持逆向转化方法!"); &#125; &#125;&#125; 看到了吧，烦人的Getter和Setter方法已经去掉了。但是上边的例子根本不足以体现lombok的强大。我希望写一些网上很难查到，或者很少人进行说明的lombok的使用以及在使用时程序语义上的说明。比如:@Data,@AllArgsConstructor,@NoArgsConstructor..这些我就不进行一一说明了，请大家自行查询资料. bean中的链式风格什么是链式风格？我来举个例子，看下面这个Student的bean: 123456789101112131415161718192021public class Student &#123; private String name; private int age; public String getName() &#123; return name; &#125; public Student setName(String name) &#123; this.name = name; return this; &#125; public int getAge() &#123; return age; &#125; public Student setAge(int age) &#123; return this; &#125;&#125; 仔细看一下set方法，这样的设置便是chain的style，调用的时候，可以这样使用: 123Student student = new Student() .setAge(24) .setName("zs"); 相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用lombok进行改善呢，请使用 @Accessors(chain = true),看如下代码: 1234567@Accessors(chain = true)@Setter@Getterpublic class Student &#123; private String name; private int age;&#125; 这样就完成了一个对于bean来讲很友好的链式操作。 静态构造方法静态构造方法的语义和简化程度真的高于直接去new一个对象。比如new一个List对象，过去的使用是这样的: 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 看一下guava中的创建方式: 1List&lt;String&gt; list = Lists.newArrayList(); Lists命名是一种约定(俗话说：约定优于配置)，它是指Lists是List这个类的一个工具类，那么使用List的工具类去产生List，这样的语义是不是要比直接new一个子类来的更直接一些呢，答案是肯定的，再比如如果有一个工具类叫做Maps，那你是否想到了创建Map的方法呢： 1HashMap&lt;String, String&gt; objectObjectHashMap = Maps.newHashMap(); 好了，如果你理解了我说的语义，那么，你已经向成为java程序员更近了一步了。 再回过头来看刚刚的Student，很多时候，我们去写Student这个bean的时候，他会有一些必输字段，比如Student中的name字段，一般处理的方式是将name字段包装成一个构造方法，只有传入name这样的构造方法，才能创建一个Student对象。 接上上边的静态构造方法和必传参数的构造方法，使用lombok将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）: 12345678@Accessors(chain = true)@Setter@Getter@RequiredArgsConstructor(staticName = "ofName")public class Student &#123; @NonNull private String name; private int age;&#125; 测试代码: 1Student student = Student.ofName("zs"); 这样构建出的bean语义是否要比直接new一个含参的构造方法(包含 name的构造方法)要好很多。 当然，看过很多源码以后，我想相信将静态构造方法ofName换成of会先的更加简洁: 12345678@Accessors(chain = true)@Setter@Getter@RequiredArgsConstructor(staticName = "of")public class Student &#123; @NonNull private String name; private int age;&#125; 测试代码: 1Student student = Student.of("zs"); 当然他仍然是支持链式调用的: 1Student student = Student.of("zs").setAge(24); 这样来写代码，真的很简洁，并且可读性很强。 使用builderBuilder模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。 今天其实要说的是一种变种的builder模式，那就是构建bean的builder模式，其实主要的思想是带着大家一起看一下lombok给我们带来了什么。 看一下Student这个类的原始builder状态: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Student &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public static Builder builder()&#123; return new Builder(); &#125; public static class Builder&#123; private String name; private int age; public Builder name(String name)&#123; this.name = name; return this; &#125; public Builder age(int age)&#123; this.age = age; return this; &#125; public Student build()&#123; Student student = new Student(); student.setAge(age); student.setName(name); return student; &#125; &#125;&#125; 调用方式: 1Student student = Student.builder().name("zs").age(24).build(); 这样的builder代码，让我是在恶心难受，于是我打算用lombok重构这段代码: 12345@Builderpublic class Student &#123; private String name; private int age;&#125; 调用方式: 1Student student = Student.builder().name("zs").age(24).build(); 代理模式正如我们所知的，在程序中调用rest接口是一个常见的行为动作，如果你和我一样使用过spring 的RestTemplate,我相信你会我和一样，对他抛出的非http状态码异常深恶痛绝。 所以我们考虑将RestTemplate最为底层包装器进行包装器模式的设计: 123456789public abstract class FilterRestTemplate implements RestOperations &#123; protected volatile RestTemplate restTemplate; protected FilterRestTemplate(RestTemplate restTemplate)&#123; this.restTemplate = restTemplate; &#125; //实现RestOperations所有的接口&#125; 然后再由扩展类对FilterRestTemplate进行包装扩展: 123456789101112131415161718192021222324public class ExtractRestTemplate extends FilterRestTemplate &#123; private RestTemplate restTemplate; public ExtractRestTemplate(RestTemplate restTemplate) &#123; super(restTemplate); this.restTemplate = restTemplate; &#125; public &lt;T&gt; RestResponseDTO&lt;T&gt; postForEntityWithNoException(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123; RestResponseDTO&lt;T&gt; restResponseDTO = new RestResponseDTO&lt;T&gt;(); ResponseEntity&lt;T&gt; tResponseEntity; try &#123; tResponseEntity = restTemplate.postForEntity(url, request, responseType, uriVariables); restResponseDTO.setData(tResponseEntity.getBody()); restResponseDTO.setMessage(tResponseEntity.getStatusCode().name()); restResponseDTO.setStatusCode(tResponseEntity.getStatusCodeValue()); &#125;catch (Exception e)&#123; restResponseDTO.setStatusCode(RestResponseDTO.UNKNOWN_ERROR); restResponseDTO.setMessage(e.getMessage()); restResponseDTO.setData(null); &#125; return restResponseDTO; &#125;&#125; 包装器ExtractRestTemplate很完美的更改了异常抛出的行为，让程序更具有容错性。在这里我们不考虑ExtractRestTemplate完成的功能，让我们把焦点放在FilterRestTemplate上，“实现RestOperations所有的接口”,这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时,如下: 1234567891011121314151617181920212223242526272829public abstract class FilterRestTemplate implements RestOperations &#123; protected volatile RestTemplate restTemplate; protected FilterRestTemplate(RestTemplate restTemplate) &#123; this.restTemplate = restTemplate; &#125; @Override public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123; return restTemplate.getForObject(url,responseType,uriVariables); &#125; @Override public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException &#123; return restTemplate.getForObject(url,responseType,uriVariables); &#125; @Override public &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException &#123; return restTemplate.getForObject(url,responseType); &#125; @Override public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123; return restTemplate.getForEntity(url,responseType,uriVariables); &#125; //其他实现代码略。。。&#125; 我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用lombok提供的代理注解优化了我的代码(@Delegate): 12345@AllArgsConstructorpublic abstract class FilterRestTemplate implements RestOperations &#123; @Delegate protected volatile RestTemplate restTemplate;&#125; 这几行代码完全替代上述那些冗长的代码。是不是很简洁，做一个拥抱lombok的程序员吧。 重构需求案例项目需求项目开发阶段，有一个关于下单发货的需求：如果今天下午3点前进行下单，那么发货时间是明天，如果今天下午3点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加1天为发货时间。 思考与重构我相信这个需求看似很简单，无论怎么写都可以完成。 很多人可能看到这个需求，就动手开始写Calendar或Date进行计算，从而完成需求。 而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用Calendar或Date去解决，一定要看场景。 对于时间的计算我们要考虑joda-time这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。 请读者先考虑这个需求如何用java代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些: 12345678910111213final DateTime DISTRIBUTION_TIME_SPLIT_TIME = new DateTime().withTime(15,0,0,0);private Date calculateDistributionTimeByOrderCreateTime(Date orderCreateTime)&#123; DateTime orderCreateDateTime = new DateTime(orderCreateTime); Date tomorrow = orderCreateDateTime.plusDays(1).toDate(); Date theDayAfterTomorrow = orderCreateDateTime.plusDays(2).toDate(); return orderCreateDateTime.isAfter(DISTRIBUTION_TIME_SPLIT_TIME) ? wrapDistributionTime(theDayAfterTomorrow) : wrapDistributionTime(tomorrow);&#125;private Date wrapDistributionTime(Date distributionTime)&#123; DateTime currentDistributionDateTime = new DateTime(distributionTime); DateTime plusOneDay = currentDistributionDateTime.plusDays(1); boolean isSunday = (DateTimeConstants.SUNDAY == currentDistributionDateTime.getDayOfWeek()); return isSunday ? plusOneDay.toDate() : currentDistributionDateTime.toDate() ;&#125; 读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回，这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了3遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。 提高方法如果你做了3年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写java的程序员，就好好的思考和重构代码吧。写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的java程序员。提高代码水平最好的方法就是有条理的重构！(注意：是有条理的重构) 设计模式设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。 我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。 业务驱动技术 or 技术驱动业务业务驱动技术 or 技术驱动业务 ？ 其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个java程序员，我们应该如何判断自己所处于的位置. 业务驱动技术：如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。 技术驱动业务：如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益，比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。 我相信大部分人还都处于业务驱动技术的方向吧。 所以你既然不能驱动业务，那就请拥抱业务变化吧。 代码设计一直在做java后端的项目，经常会有一些变动，我相信大家也都遇到过。 比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。 慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。 说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。 java编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计! 你真的优秀吗？真不好意思，我取了一个这么无聊的标题。 国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？ “平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？ 答案就是: 多看成熟框架的源码 多回头看自己的代码 勤于重构 你真的优秀吗？ 如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。 即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写java代码的程序员了。 技能UML不想多讨论UML相关的知识，但是我觉得你如果真的会写java，请先学会表达自己，UML就是你说话的语言，做一名优秀的java程序员，请至少学会这两种UML图： 类图 时序图 clean code我认为保持代码的简洁和可读性是代码的最基本保证，如果有一天为了程序的效率而降低了这两点，我认为是可以谅解的，除此之外，没有任何理由可以让你任意挥霍你的代码。 读者可以看一下Robert C. Martin出版的《Clean Code》（代码整洁之道） 这本书 可以参考美团文章聊聊clean code 也可以看一下阿里的Java编码规范 无论如何，请保持你的代码的整洁。 linux 基础命令这点其实和会写java没有关系，但是linux很多时候确实承载运行java的容器，请学好linux的基础命令。 参考鸟哥的《Linux私房菜》 总结java是一个大体系，今天讨论并未涉及框架和架构相关知识，只是讨论如何写好代码。 本文从写java程序的小方面一直写到大方面，来阐述了如何才能写好java程序，并告诉读者们如何才能提高自身的编码水平。 我希望看到这篇文章的各位都能做一个优秀的java程序员。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+Next配置Blog]]></title>
      <url>%2F2017%2F03%2F20%2F%E5%93%8E%E6%8A%98%E8%85%BE%2FHexo%2BNext%E9%85%8D%E7%BD%AEBlog%2F</url>
      <content type="text"><![CDATA[配置环境安装Node（必须）安装Git（必须） 正式安装Hexo为了不跳坑╮(╯▽╰)╭，请先建好你要放博客的目录，进到目录中再进行以下操作如我的：cd ~/Blog 1、安装Hexo1sudo npm install hexo-cli -g 2、初始化Hexo1hexo init + 需要初始化的目录 这里建议init与你github仓库一样的名字xxxx.github.io 3、安装依赖进入初始化后的目录：cd xxxx.github.io安装Hexo依赖1npm install 4、生成静态页面1hexo generate # 简写 hexo g 本地预览其实不需要执行这部也行 5、启动本地服务1hexo server # 简写 hexo s 调试加参数：--debug 6、测试浏览器输入： http://localhost:4000若能正常显示网页切没有任何报错，恭喜你！到此Hexo的安装就完成了 Next 安装在本地博客目录xxxx.github.io下操作 1、安装 Next 主题1git clone https://github.com/iissnan/hexo-theme-next themes/next 2、使用 Next 主题首先，复制一份打开本地博客目录下的 _config.yml 文件，命名为 _config_bak.yml，做为备份，以防改错然后，使用文本编辑器打开本地博客目录下的 _config.yml 文件，搜索，定位 theme 键值，将 theme 的值修改为 next1theme: next # 刚刚安装的主题名称 注意：Hexo配置文件中所有的配置项冒号与值之间都要有一个空格，不然配置不会生效重启本地服务，访问 http://localhost:4000 就能看到 Next 主题默认界面了 3、配置由于配置项比较多，直接注释，放出配置文件 站点配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/## 设置项的键值之间一定要有空格# Sitetitle: luosv`s blog # 网站标题subtitle: 副标题起个啥呢 # 网站副标题description: About Life, Books and Code. # 网站描述 主要用于SEOauthor: luosv # 作者名字 用于主题显示文章的作者language: zh-Hans # 网站使用的语言timezone: # 网站时区 Hexo 默认使用您电脑的时区# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/## 这项暂时不需要配置，绑定域名后，要创建 sitemap.xml 时再配置该项url: http://yoursite.com # 网址root: / # 网站根目录permalink: :year/:month/:day/:title/ # 文章的永久链接格式permalink_defaults: # 永久链接中各部分的默认值# Directory# 目录，如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值source_dir: source # 资源文件夹，这个文件夹用来存放内容public_dir: public # 公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags # 标签文件夹archive_dir: archives # 归档文件夹category_dir: categories # 分类文件夹code_dir: downloads/code # Include code 文件夹i18n_dir: :lang # 国际化（i18n）文件夹skip_render: # 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径# Writing# 文章布局、写作格式的定义，不建议修改new_post_name: :title.md # File name of new posts 新文章的文件名称default_layout: post # 预设布局titlecase: false # Transform title into titlecase 把标题转换为 title caseexternal_link: true # Open external links in new tab 在新标签中打开链接filename_case: 0 # 把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false # 显示草稿post_asset_folder: false # 启动 Asset 文件夹relative_link: false # 把链接改为与根目录的相对位址future: true # 显示未来的文章highlight: # 代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorized # 默认分类category_map: # 分类别名tag_map: # 标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/## Hexo 使用 Moment.js 来解析和显示时间date_format: YYYY-MM-DD # 日期格式time_format: HH:mm:ss # 时间格式# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page # 分页目录# Searchsearch: path: search.xml field: post format: html limit: 10000# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next # 当前主题名称，值为false时禁用主题# Deployment## Docs: https://hexo.io/docs/deployment.html## 部署部分的设置deploy: type: git # 使用 Git 提交 repository: https://github.com/xxx/xxx.github.io.git # 存放博客的仓库地址 主题配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# 设置项的键值之间一定要有空格# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico# Set default keywords (Use a comma to separate)# 设置关键字keywords: &quot;Life, Books, Code&quot;# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss:# Specify the date when the site was setup# 设置博客开始时间since: 2017# icon between year and author @Footerauthoricon: heart# Footer `powered-by` and `theme-info` copyrightcopyright: true# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# ---------------------------------------------------------------# Menu Settings 设置菜单# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)# 此处可以修改显示顺序，调换下面的配置项即可menu: home: / # 主页 categories: /categories # 分类页 archives: /archives # 归档页 tags: /tags # 标签页 about: /about # 关于页面 #sitemap: /sitemap.xml #commonweal: /404.html # 公益404# Enable/Disable menu icons.# 设定菜单项的图标# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwesome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings 设置风格# ---------------------------------------------------------------# Schemes#scheme: Muse # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白#scheme: Mist # Muse 的紧凑版本，整洁有序的单栏外观scheme: Pisces # 双栏 Scheme，小家碧玉似的清新# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Sidebar Settings 设置侧栏# ---------------------------------------------------------------# Social Links# 侧栏社交链接# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)social: GitHub: https://github.com/luosv 简书: http://www.jianshu.com/u/1b1a17e2c18b Weibo: http://weibo.com/5394586088/profile?topnav=1&amp;wvr=6 LOFTER: http://luosv.lofter.com/# Social Links Icons# 链接的图标# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of the item and value is the name of FontAwesome icon. Key is case-senstive.# When an globe mask icon presenting up means that the item has no mapping icon.social_icons: enable: true # Icon Mappings. # KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo 简书: book LOFTER: camera# Sidebar Avatar# 设置头像# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: /uploads/images/avatar.jpg# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left # 靠左放置 #position: right # 靠右放置 # Sidebar Display, available value: # 设置侧栏显示的时机 # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post # 默认行为，在文章页面（拥有目录列表）时显示 #display: always # 在所有页面中都显示 #display: hide # 在所有页面中都隐藏（可以手动展开） #display: remove # 完全移除 # Sidebar offset from top menubar in pixels. offset: 12 offset_float: 0 # Back to top in sidebar b2t: false # Scroll percent label in b2t button scrollpercent: false# Blog rolls# 友情链接#links_title: Links#links_layout: block#links_layout: inlinelinks:# ---------------------------------------------------------------# 其它配置# ---------------------------------------------------------------# 打赏配置# 打赏说明文本reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！# 微信收款二维码wechatpay: /uploads/images/wechat-reward-image.jpg# 支付宝收款二维码alipay: /uploads/images/alipay-reward-image.jpg# 网站logo设置# 没效果，报错，后面想办法解决# favicon: /favicon.ico# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false # 设置是否显示阅读全文，文章较多的话，有必要设置为 true length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: false min2read: false# Wechat Subscriber#wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg #description: ex. subscribe to my blog by scanning my public wechat account# Declare license on postspost_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image:# Code Highlight theme# 代码高亮主题# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortName#duoshuo_shortname:# Disqus#disqus_shortname:# Hypercomments#hypercomments_id:# Gentie productKey#gentie_productKey:# changyanchangyan: enable: false appid: appkey:# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)#livere_uid: your uid# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share#jiathis:# Warning: JiaThis does not support https.#add_this_id:# Share#duoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru/#yandex_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# 一些第三方服务设置，这里只提一下”多说“，其他的请参考官方介绍# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: true user_id: 0 # **这里不要动，千万别动** admin_nickname: Author# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 3CJD75sRcSicWe9kgRSIlGrS-gzGzoHsz app_key: huqzr6iJ2YXBINGz7oaWmy3x# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot; hits_stats: &quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;# Local search 本地搜索local_search: enable: true# External URL with BASE64 encrypt &amp; decrypt# Usage: &#123;% exturl text url &quot;title&quot; %&#125;# Alias: &#123;% extlink text url &quot;title&quot; %&#125;exturl: false#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Canvas-nestcanvas_nest: false# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.0 基础配置1、创建分类页面 打开命令行，定位到 xxxx.github.io 目录 新建一个页面，命名为 categories 1hexo new page categories 根据提示找到新建的 index.md 文件，编辑 title 即分类页的标题 2、创建标签云页面 打开命令行，定位到 xxxx.github.io 目录 新建一个页面，命名为 tags 1hexo new page tags 根据提示找到新建的 index.md 文件，编辑 title 即标签页的标题 3、配置模板在站点根目录的 scaffolds 目录下的 post.md 文件，打开编辑 1234title: &#123;&#123; title &#125;&#125; # 文章标题date: &#123;&#123; date &#125;&#125; # 日期categories: # 分类tags: # 标签 原只有 title 和 date，添加你创建的分类 categories 和标签 tags 4、写博客与发布经过上述步骤，本地博客和主题设置已经完成，那么接下来就是写博客了。 博客文件需要存放到 xxxx.github.io/source/_posts 文件夹中，在该文件夹下面你可以按照你的博客分类建立一系列的文件夹来管理博客原文件 1、用 Markdown 写文章 不管用什么编辑 Markdown 文件，最后生成的 md 文件放到 xxxx.github.io/source/_posts 文件夹或其子文件夹中即可，如： 1234567891011---title: Hexo+Next配置Blog # 这是标题categories: # 这里写的分类会自动汇集到 categories 页面上，分类可以多级- 哎折腾 # 一级分类- 技术流 # 二级分类 tags: # 这里写的标签会自动汇集到 tags 页面上- Hexo # 可配置多个标签，注意格式- Blog---## This is my first blog! 文字居中（写博客时） 在你博客文章中需要居中处加上下面这段代码即可，中间的文字改成你所需要的文字 1234&gt; &lt;blockquote class="blockquote-center"&gt;&gt; 不忘初心，这里可以写多行文字&gt; &lt;/blockquote&gt;&gt; 注意：分类和标签是自动维护的，关键是的文章要按照规定的格式写，如上格式，可以参考 说明：Next 主题会自动生成目录，这也省了不少事。 2、在本地运行测试 打开命令行定位到 xxxx.github.io 目录，输入命令： 1hexo s # 这是简写 == hexo server # 启动服务预览 3、在浏览器查看效果 在浏览器中输入 http://localhost:4000 访问本地博客，看看效果吧 4、安装自动部署发布工具 这里用到了 hexo-deployer-git，使用如下命令安装： 1npm install hexo-deployer-git --save 5、发布到 GitHubPages 确认在本地上显示无误之后，就可以将 md 转为 静态网页文件，然后发布到 GitHubPages 上去了 123456hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署也可以一次性执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 如果是第一次部署，终端会提示要求输入用户名和密码。等命令执行完之后，过几分钟打开 http://xxx.github.io 即可看到你的个人博客了。以后要发布新文章，执行上述命令即可 Hexo 常用命令Hexo 安装升级 123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 常用简写 12345hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 启动本地服务 1234hexo server #Hexo #会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 监视文件变动 123hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动hexo clean #清除缓存 网页正常情况下可以忽略此条命令 部署 12345#两个命令的作用是相同的hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 草稿 1234# 新建草稿hexo new draft &lt;title&gt;# 发布草稿为posthexo publish draft &lt;title&gt; 模板 12345678hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo new [layout] &lt;title&gt;hexo new photo &quot;My Gallery&quot;hexo new &quot;Hello World&quot; --lang tw 写作时间 1234567变量 描述:title 标题:year 建立的年份（4 位数）:month 建立的月份（2 位数）:i_month 建立的月份（去掉开头的零）:day 建立的日期（2 位数）:i_day 建立的日期（去掉开头的零） 个性化配置上面完成的博客样子看起来太普通了，下面做些个性化的增强配置 圆形头像现在很多网站都流行圆形头像，但 NexT 主题默认还不支持，当然我们可以很方便地添加圆形头像效果，将以下代码覆盖主题目录下 source/css/_common/components/sidebar/sidebar-author.styl 文件内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 腾讯公益404页面腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！效果如 http://www.ixirong.com/404.html 使用方法，新建 404.html 页面，放到主题的 source 目录下，内容如下： 1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="your site url " homePageName="回到我的主页"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 为博客加上GitHub丝带如果是 Next 主题（其他主题也差不多），添加 GitHub 丝带：在 themes\next\layout\_layout.swig 中加入相关代码，记得修改自己的链接 相关代码你可以在 GitHub 官方网站 GitHub Ribbons 上进行选择 加入作者版权信息我们可以为博客文章加入作者版权信息。例如本文地址：http://www......./ 转载请注明出处，谢谢！等等。对Next主题而言，先找到/themes/next/layout/_macro/post.swig，再找到其中的微信订阅部分，如下所示： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后直接在其上面添加如下代码段： 123456789&lt;div align="center"&gt; &#123;% if not is_index %&#125; &lt;div class="copyright"&gt; &lt;p&gt;&lt;span&gt; &lt;b&gt;本文地址：&lt;/b&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;&lt;br /&gt;&lt;b&gt;转载请注明出处，谢谢！&lt;/b&gt; &lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 当然，在上面这段代码，你可以进行一些个性化编写，可以展示你自己个性化的版权信息 为博客加入动态背景首先找到\themes\next\layout\_layout.swig，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改） 默认灰色线条 1&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 浅蓝色线条 1&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"&gt;&lt;/script&gt; 然后在themes\source\js\src下新建文件particle.js写上以下代码: 1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 为博客加入鼠标点击显示红心鼠标点击小红心在\themes\next\source\js\src文件目录下添加love.js文件。内容为： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 找到\themes\next\layout\_layout.swing文件，在文件的后面，&lt;/body&gt;之前 添加以下代码： 12&lt;!-- 小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 添加Local Search功能安装 hexo插件在你的站点文件夹中，用shell等运行下面这行代码： 1npm install hexo-generator-searchdb --save 编辑站点配置文件 添加以下字段： 12345search: path: search.xml field: post format: html limit: 10000 启用本地搜索 编辑主题配置文件启用本地搜索 123# Local searchlocal_search: enable: true 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示： 1$font-size-base = 16px # 我觉得还是默认的14比较合适 不蒜子统计找到\themes\next\layout\_partials\footer.swig文件，加入下面不蒜子统计代码： 12345 | 本页点击 &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt; 次 | 本站总点击 &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次 | 您是第 &lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; 位访客&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 在标题下添加【阅读量】等现在要添加的阅读量统计也依赖下面这段代码 12&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 打开/themes/next/layout/_macro/post.swig，找到标签&lt;div class=&quot;post-meta&quot;&gt;&lt;/div&gt;，在该标签内部合适的位置（如time和categories之间或categories后面）添加： 123&#123;% if not is_index %&#125; &lt;span id="busuanzi_container_page_pv"&gt; | 阅读量 &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt; 次&lt;/span&gt;&#123;% endif %&#125; 将阅读量改为热度（更个性）还可以继续修改，看到好多人的博客不是阅读次数（阅读量），而是热度 188 ℃，那么可以继续这样修改，首先在Next主题的/themes/next/languages/zh-Hans文件中查找”阅读次数“这几个字，可以看到，在post中的visitors被定义为“阅读次数”，把这里的“阅读次数”改为“热度”。 那么怎么在页面中显示呢。打开Next主题文件夹中layout/_macro/post.swig，在这个文件里加上摄氏度的标志，在&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;下面增加一行&lt;span&gt;℃&lt;/span&gt;即可 修改标题下分类等的样式在Next主题中，我用的是LeanCloud数据统计，默认样式是在统计数据前有个小眼睛，我感觉不好看，想把它去掉，那么打开/themes/next/layout/_macro/post.swig，找到标签&lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;，去掉下面这段代码即可： 123&lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-eye"&gt;&lt;/i&gt;&lt;/span&gt; 设置动态title在 \themes\next\source\js\src 目录下新建 dytitle.js 。添加以下内容： 1234567891011121314151617&lt;!--崩溃欺骗--&gt;var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/TEP.ico"); document.title = ' 页面崩溃啦 ~ | cwyaml！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/favicon.ico"); document.title = ' 噫又好了~ ' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;); 更改 \themes\next\layout\_layout.swig 。在 &lt;/body 之前添加： 12&lt;!--卖萌--&gt;&lt;script type="text/javascript" src="/js/src/dytitle.js"&gt;&lt;/script&gt; 首页分割线在 \themes\next\source\css\_custom\custom.styl 文件中添加以下代码，可以修改博客首页中每篇文章的分割线长度，我设置为了100%长度 1234567891011//index页面中每篇文章相隔的那条线.posts-expand &#123; .post-eof &#123; display: block; margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 100%; height: 3px; background: $grey-light; text-align: center; &#125;&#125; 字体、颜色等设置在\themes\next\source\css\_variables\custom.styl 文件中添加以下代码。具体功能我已经做了注释 12345678910111213141516// 标题，修改成你期望的字体族$font-family-headings = Georgia, sans// 修改成你期望的字体族$font-family-base = "Microsoft YaHei", Verdana, sans-serif// 代码字体$code-font-family = "Input Mono", "PT Mono", Consolas, Monaco, Menlo, monospace// 正文字体的大小$font-size-base = 16px// 代码字体的大小$code-font-size = 14px// 代码块颜色$code-foreground = #dd0055// Background color for &lt;body&gt;$body-bg-color = #e7e5dc //theme mist use #fdfdfd// text-color$text-color = #353535 n(≧▽≦)n 欢迎参观我的博客！]]></content>
    </entry>

    
  
  
</search>
